package panic_defer_recover

import (
	"errors"
	"fmt"
	"log"
	"time"
)

func RunSnippet1() {
	a()
	fmt.Println("The program is finished.")
}

func a() {
	defer func() {
		fmt.Println("This message will be displayed.")
		if err := recover(); err != nil {
			fmt.Printf("Rceived panic: `%v`, but program continues.\n", err)
		}
	}()
	b()
	fmt.Println("This message will not be displayed.")
}

func b() {
	panic("panic occured from func b.")
	fmt.Println("This message will not be displayed.")
}

func RunSnippet2() {
	run()
}

func run() {
	s := make([]string, 3)
	if v, e := elementValue(s, 5); e != nil {
		log.Printf("Error: %s", e)
	} else {
		fmt.Printf("value is %v", v)
	}
}

// general function to get element value of a slice with no panic
func elementValue(slice []string, index int) (value string, err error) {
	defer func() {
		if e := recover(); e != nil {
			err = errors.New(fmt.Sprintf("%s", e))
		}
	}()
	value = slice[index]
	return
}

// ReturnedInterfaceValue demonstrates that the underlying type of
// the interface value returned by recover() is not error.
func ReturnedInterfaceValue() {
	defer func() {
		if v := recover(); v != nil {
			if err, ok := v.(error); ok == true {
				fmt.Printf("error: %v\n", err) // will not print
			} else {
				fmt.Printf("interface: %v\n", v) // will print
			}
		}
	}()
	panic("wrong!")
}

// ChildGoroutinePanic demonstrates that the panic generated in one goroutine can only
// been recovered in that goroutine, the parent-goroutines cannot recover it.
func ChildGoroutinePanic() {
	defer func() {
		if v := recover(); v != nil {
			fmt.Printf("I can't catch other goroutine's panic: %v\n", v)
		}
	}()

	done := make(chan int)
	go func() {
		defer func() {
			// child goroutine didn't recover
			fmt.Println("I am a child goroutine, and I don't recover the panic generated by me.")
			done <- 1
		}()
		panic("I will destroy the entire process!")
	}()

	<-done
}

// PanicTerminateWholeProgram demonstrates that the un-recovered panic in one goroutine
// will terminate the whole program. Run the command:
//   $ go test -v -run=PanicTerminateWholeProgram ./panic_defer_recover
// After 3 seconds, the goroutine 1 will panic, and the main goroutine will be terminated too.
func PanicTerminateWholeProgram() {
	// here is main goroutine

	go func() {
		// here is goroutine 1
		time.Sleep(time.Second * 3)
		panic("generated from certain goroutine")
	}()

	s := 0.5
	for range time.Tick(time.Second / 2) {
		fmt.Printf("%.1f seconds passed ...\n", s)
		s += 0.5
	}
}

// RecoverMustInDefer demonstrates that recover only works in defer function.
func RecoverMustInDefer() {
	fmt.Println(recover()) // print <nil>
	panic("wrong")
	fmt.Println(recover()) // unreachable code
}
